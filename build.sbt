import sbt.io.FileFilter

name := "rest-query-function"

version := "1.0"

scalaVersion := "2.13.8"

libraryDependencies ++= Seq(
  "com.amazonaws" % "aws-lambda-java-core" % "1.2.1",
  "com.lihaoyi" %% "requests" % "0.6.5",
  "com.amazonaws" % "aws-lambda-java-events" % "3.7.0"
)

enablePlugins(AssemblyPlugin)

mainClass := Some("RestQueryFunction")

assembly / assemblyMergeStrategy := {
  case PathList("META-INF", xs @ _*) => MergeStrategy.discard
  case x                             => MergeStrategy.first
}

assembly / assemblyExcludedJars := {
// Exclude specific jar files from the assembly.
  (fullClasspath in assembly).value.filter { attributedFile =>
    val fileName = attributedFile.data.getName
    fileName.startsWith("aws-lambda-java-core")
    fileName.startsWith("requests")
  }
}

val packageLayer = taskKey[File]("Package Lambda layer")

packageLayer := {
  val baseDir = new File(".layer/")
  val layerDir = new File(".layer/java/")
  val libDir = new File(".layer/java/lib/")
  IO.delete(layerDir)
  IO.createDirectory(libDir)

  // Copy all the jar files generated by the `assembly` task to the `layerDir` directory.
  val jars = (assembly / fullClasspath).value.files
    .filter(_.name.endsWith(".jar"))
  jars.foreach { jar =>
    IO.copyFile(jar, libDir / jar.name)
  }

  // Add your dependencies to the layerDir directory.

  // Create the classpath.txt file that includes the path of all the jar files in the `layerDir` directory.
  val classpath = jars.map(_.getName).mkString(":")
  IO.write(layerDir / "classpath.txt", classpath)

  // Create a layer archive file that includes all the files in the `layerDir` directory.
  val layerFile = file("layer/rest-query-layer.zip")
  IO.zip(Path.allSubpaths(baseDir), layerFile)
  layerFile
}
